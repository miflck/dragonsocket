<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Display View - All Drawings</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <style>
      body {
        margin: 0;
        padding: 20px;
        font-family: Arial, sans-serif;
        background-color: #f0f0f0;
      }
      h1 {
        text-align: center;
        color: #333;
      }
      #canvasContainer {
        display: flex;
        justify-content: center;
        margin-top: 20px;
      }
      .info {
        text-align: center;
        margin-bottom: 20px;
        color: #666;
      }
      .status {
        text-align: center;
        margin-bottom: 10px;
        padding: 10px;
        background-color: #e8f5e8;
        border-radius: 5px;
        color: #2d5d2d;
      }
    </style>
  </head>
  <body>
    <h1>Display View - All Drawings</h1>
    <div class="info">
      <p>This view shows all drawings from connected users in real-time.</p>
      <p>Open drawing clients at: <a href="/" target="_blank">/</a></p>
    </div>
    <div class="status" id="status">Connecting to server...</div>
    <div id="canvasContainer"></div>

    <script>
      let socket;
      let statusElement;
      let clientCursors = {}; // Store cursor positions for each client
      let settings = {
        canvas: { width: 800, height: 600, backgroundColor: "#FFFFFF" },
        drawing: { cursorSize: 20, cursorOpacity: "99" },
        ui: { clientIdLength: 8, cursorIdLength: 6, statusUpdateDelay: 500, clearStatusDelay: 2000 },
        server: { cursorInactiveTimeout: 5000 },
      };

      function setup() {
        // Create canvas using default settings (will be updated when clients send settings)
        let canvas = createCanvas(settings.canvas.width, settings.canvas.height);
        canvas.parent("canvasContainer");

        // Set background
        background(settings.canvas.backgroundColor);

        // Get status element
        statusElement = document.getElementById("status");

        // Initialize socket connection
        socket = io();

        // Join the display room
        socket.emit("join-display");

        // Handle connection status
        socket.on("connect", () => {
          statusElement.textContent = "Connected - Listening for drawings...";
          statusElement.style.backgroundColor = "#e8f5e8";
          console.log("Connected to server as display client");
        });

        socket.on("disconnect", () => {
          statusElement.textContent = "Disconnected from server";
          statusElement.style.backgroundColor = "#f5e8e8";
          clientCursors = {}; // Clear cursors on disconnect
        });

        // Listen for drawing data from all drawing clients
        socket.on("drawing", (data) => {
          // Draw the line with the client's assigned color
          stroke(data.color);
          strokeWeight(data.weight);
          line(data.x1, data.y1, data.x2, data.y2);

          // Update status to show activity
          statusElement.textContent = "Connected - Receiving drawings...";

          // Reset status after a brief moment
          setTimeout(() => {
            statusElement.textContent = "Connected - Listening for drawings...";
          }, settings.ui.statusUpdateDelay);
        });

        // Listen for cursor position updates
        socket.on("cursor-position", (data) => {
          // Store cursor position and color for this client
          clientCursors[data.clientId] = {
            x: data.x,
            y: data.y,
            color: data.color,
            lastSeen: Date.now(),
          };
        });

        // Handle client disconnections
        socket.on("client-disconnected", (data) => {
          // Remove cursor for disconnected client
          delete clientCursors[data.clientId];
        });

        // Handle clear canvas from drawing clients
        socket.on("clear", () => {
          background(settings.canvas.backgroundColor);
          statusElement.textContent = "Canvas cleared by drawing client";

          setTimeout(() => {
            statusElement.textContent = "Connected - Listening for drawings...";
          }, settings.ui.clearStatusDelay);
        });

        console.log("Display view initialized");
      }

      function draw() {
        // Don't clear the background - we want to keep the drawings

        // Draw cursors for each connected client
        for (let clientId in clientCursors) {
          let cursor = clientCursors[clientId];

          // Remove old cursors (inactive for more than configured timeout)
          if (Date.now() - cursor.lastSeen > settings.server.cursorInactiveTimeout) {
            delete clientCursors[clientId];
            continue;
          }

          // Draw cursor indicator with client's color
          push();

          // Cursor circle with client's assigned color
          fill(cursor.color + settings.drawing.cursorOpacity); // Add transparency
          stroke(cursor.color);
          strokeWeight(2);
          ellipse(cursor.x, cursor.y, settings.drawing.cursorSize, settings.drawing.cursorSize);

          // Client ID text (if enabled)
          if (settings.ui.showClientIds) {
            fill(255);
            stroke(0);
            strokeWeight(1);
            textAlign(CENTER, CENTER);
            textSize(10);
            text(clientId.substring(0, settings.ui.cursorIdLength), cursor.x, cursor.y);

            // Client ID label above cursor with client's color
            fill(cursor.color);
            noStroke();
            textAlign(LEFT, BOTTOM);
            textSize(12);
            text("ID: " + clientId.substring(0, settings.ui.clientIdLength), cursor.x + 15, cursor.y - 5);
          }

          pop();
        }
      }

      // Disable all mouse interactions
      function mousePressed() {
        return false;
      }

      function mouseDragged() {
        return false;
      }

      function mouseReleased() {
        return false;
      }

      // Disable keyboard interactions
      function keyPressed() {
        return false;
      }
    </script>
  </body>
</html>
