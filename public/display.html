<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Display View - All Drawings</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <script src="dragon.js"></script>
    <style>
      body {
        margin: 0;
        padding: 20px;
        font-family: Arial, sans-serif;
        background-color: #f0f0f0;
      }
      h1 {
        text-align: center;
        color: #333;
      }
      #canvasContainer {
        display: flex;
        justify-content: center;
        margin-top: 20px;
      }
      .info {
        text-align: center;
        margin-bottom: 20px;
        color: #666;
      }
      .status {
        text-align: center;
        margin-bottom: 10px;
        padding: 10px;
        background-color: #e8f5e8;
        border-radius: 5px;
        color: #2d5d2d;
      }
    </style>
  </head>
  <body>
    <h1>Display View - All Drawings</h1>
    <div class="info">
      <p>This view shows dragons following each connected user's cursor in real-time.</p>
      <p>Open drawing clients at: <a href="/" target="_blank">/</a></p>
    </div>
    <div class="status" id="status">Connecting to server...</div>
    <div id="canvasContainer"></div>

    <script>
      let socket;
      let statusElement;
      let dragons = {}; // Store dragon instances for each client
      let settings;

      function preload() {
        settings = loadJSON("settings.json");
      }

      function setup() {
        // Create canvas using default settings (will be updated when clients send settings)
        let canvas = createCanvas(settings.canvas.width, settings.canvas.height);
        canvas.parent("canvasContainer");

        // Set background
        background(settings.canvas.backgroundColor);

        // Get status element
        statusElement = document.getElementById("status");

        // Initialize socket connection
        socket = io();

        // Join the display room
        socket.emit("join-display");

        // Handle connection status
        socket.on("connect", () => {
          statusElement.textContent = "Connected - Listening for dragons...";
          statusElement.style.backgroundColor = "#e8f5e8";
          console.log("Connected to server as display client");
        });

        socket.on("disconnect", () => {
          statusElement.textContent = "Disconnected from server";
          statusElement.style.backgroundColor = "#f5e8e8";
          dragons = {}; // Clear dragons on disconnect
        });

        // Listen for drawing data from all drawing clients
        socket.on("drawing", (data) => {
          //   // Draw the line with the client's assigned color
          //   stroke(data.color);
          //   strokeWeight(data.weight);
          //   line(data.x1, data.y1, data.x2, data.y2);
          //   // Update status to show activity
          //   statusElement.textContent = "Connected - Receiving drawings...";
          //   // Reset status after a brief moment
          //   setTimeout(() => {
          //     statusElement.textContent = "Connected - Listening for drawings...";
          //   }, settings.ui.statusUpdateDelay);

          const clientId = data.clientId;

          // Create dragon if it doesn't exist
          if (!dragons[clientId]) {
            dragons[clientId] = new Dragon(clientId, data.color, settings.dragon);
            console.log(`Created dragon for client ${clientId}`);
          }

          // Update dragon target position
          dragons[clientId].updateTarget(data.x1, data.y1);
        });

        // Listen for cursor position updates - create/update dragons
        socket.on("cursor-position", (data) => {
          const clientId = data.clientId;

          // Create dragon if it doesn't exist
          if (!dragons[clientId]) {
            dragons[clientId] = new Dragon(clientId, data.color, settings.dragon);
            console.log(`Created dragon for client ${clientId}`);
          }

          // Update dragon target position
          dragons[clientId].updateTarget(data.x, data.y);
        });

        // Handle client disconnections - remove dragons
        socket.on("client-disconnected", (data) => {
          // Remove dragon for disconnected client
          if (dragons[data.clientId]) {
            delete dragons[data.clientId];
            console.log(`Removed dragon for client ${data.clientId}`);
          }
        });

        // Handle clear canvas from drawing clients
        socket.on("clear", () => {
          background(settings.canvas.backgroundColor);
          statusElement.textContent = "Canvas cleared by drawing client";

          setTimeout(() => {
            statusElement.textContent = "Connected - Listening for drawings...";
          }, settings.ui.clearStatusDelay);
        });

        console.log("Display view initialized");
      }

      function draw() {
        // Clear background each frame
        background(settings.canvas.backgroundColor);

        // Update and draw all dragons
        for (let clientId in dragons) {
          let dragon = dragons[clientId];

          // Remove inactive dragons
          if (dragon.isInactive(settings.server.cursorInactiveTimeout)) {
            delete dragons[clientId];
            console.log(`Removed inactive dragon for client ${clientId}`);
            continue;
          }

          // Update dragon movement
          dragon.update();

          // Draw the dragon
          dragon.draw();

          // Draw client ID near dragon head (optional)
          if (settings.ui.showClientIds && dragon.isActive) {
            push();
            fill(dragon.color);
            noStroke();
            textAlign(LEFT, BOTTOM);
            textSize(12);
            text("ID: " + clientId.substring(0, settings.ui.clientIdLength), dragon.x[0] + 15, dragon.y[0] - 5);
            pop();
          }
        }
      }

      // Disable all mouse interactions
      function mousePressed() {
        return false;
      }

      function mouseDragged() {
        return false;
      }

      function mouseReleased() {
        return false;
      }

      // Disable keyboard interactions
      function keyPressed() {
        return false;
      }
    </script>
  </body>
</html>
